/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.16.4.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
import { Coin } from "@cosmjs/amino";
import { MsgExecuteContractEncodeObject } from "cosmwasm";
import { Uint128, Expiration, TokenSelect, Addr } from "./JunoSwap.types";
export interface JunoSwapMessage {
    contractAddress: string;
    sender: string;
    addLiquidity: ({ expiration, maxToken2, minLiquidity, token1Amount }: {
        expiration?: Expiration;
        maxToken2: Uint128;
        minLiquidity: Uint128;
        token1Amount: Uint128;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    removeLiquidity: ({ amount, expiration, minToken1, minToken2 }: {
        amount: Uint128;
        expiration?: Expiration;
        minToken1: Uint128;
        minToken2: Uint128;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    swapToken1ForToken2: ({ expiration, minToken2, token1Amount }: {
        expiration?: Expiration;
        minToken2: Uint128;
        token1Amount: Uint128;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    swapToken2ForToken1: ({ expiration, minToken1, token2Amount }: {
        expiration?: Expiration;
        minToken1: Uint128;
        token2Amount: Uint128;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    multiContractSwap: ({ expiration, inputToken, inputTokenAmount, outputAmmAddress, outputMinToken, outputToken }: {
        expiration?: Expiration;
        inputToken: TokenSelect;
        inputTokenAmount: Uint128;
        outputAmmAddress: Addr;
        outputMinToken: Uint128;
        outputToken: TokenSelect;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    swapTo: ({ expiration, inputAmount, inputToken, minToken, recipient }: {
        expiration?: Expiration;
        inputAmount: Uint128;
        inputToken: TokenSelect;
        minToken: Uint128;
        recipient: Addr;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
}
export declare class JunoSwapMessageComposer implements JunoSwapMessage {
    sender: string;
    contractAddress: string;
    constructor(sender: string, contractAddress: string);
    addLiquidity: ({ expiration, maxToken2, minLiquidity, token1Amount }: {
        expiration?: Expiration;
        maxToken2: Uint128;
        minLiquidity: Uint128;
        token1Amount: Uint128;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    removeLiquidity: ({ amount, expiration, minToken1, minToken2 }: {
        amount: Uint128;
        expiration?: Expiration;
        minToken1: Uint128;
        minToken2: Uint128;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    swapToken1ForToken2: ({ expiration, minToken2, token1Amount }: {
        expiration?: Expiration;
        minToken2: Uint128;
        token1Amount: Uint128;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    swapToken2ForToken1: ({ expiration, minToken1, token2Amount }: {
        expiration?: Expiration;
        minToken1: Uint128;
        token2Amount: Uint128;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    multiContractSwap: ({ expiration, inputToken, inputTokenAmount, outputAmmAddress, outputMinToken, outputToken }: {
        expiration?: Expiration;
        inputToken: TokenSelect;
        inputTokenAmount: Uint128;
        outputAmmAddress: Addr;
        outputMinToken: Uint128;
        outputToken: TokenSelect;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    swapTo: ({ expiration, inputAmount, inputToken, minToken, recipient }: {
        expiration?: Expiration;
        inputAmount: Uint128;
        inputToken: TokenSelect;
        minToken: Uint128;
        recipient: Addr;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
}
