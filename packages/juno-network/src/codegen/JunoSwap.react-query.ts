/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.13.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { Uint128, BalanceResponse, ExecuteMsg, Expiration, Timestamp, Uint64, TokenSelect, Addr, InfoResponse, InstantiateMsg, QueryMsg, Token, Token1ForToken2PriceResponse, Token2ForToken1PriceResponse } from "./JunoSwap.types";
import { JunoSwapQueryClient, JunoSwapClient } from "./JunoSwap.client";
export interface JunoSwapReactQuery<TResponse, TData = TResponse> {
  client: JunoSwapQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface JunoSwapToken2ForToken1PriceQuery<TData> extends JunoSwapReactQuery<Token2ForToken1PriceResponse, TData> {
  args: {
    token2Amount: Uint128;
  };
}
export function useJunoSwapToken2ForToken1PriceQuery<TData = Token2ForToken1PriceResponse>({
  client,
  args,
  options
}: JunoSwapToken2ForToken1PriceQuery<TData>) {
  return useQuery<Token2ForToken1PriceResponse, Error, TData>(["junoSwapToken2ForToken1Price", client?.contractAddress, JSON.stringify(args)], () => client ? client.token2ForToken1Price({
    token2Amount: args.token2Amount
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JunoSwapToken1ForToken2PriceQuery<TData> extends JunoSwapReactQuery<Token1ForToken2PriceResponse, TData> {
  args: {
    token1Amount: Uint128;
  };
}
export function useJunoSwapToken1ForToken2PriceQuery<TData = Token1ForToken2PriceResponse>({
  client,
  args,
  options
}: JunoSwapToken1ForToken2PriceQuery<TData>) {
  return useQuery<Token1ForToken2PriceResponse, Error, TData>(["junoSwapToken1ForToken2Price", client?.contractAddress, JSON.stringify(args)], () => client ? client.token1ForToken2Price({
    token1Amount: args.token1Amount
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JunoSwapInfoQuery<TData> extends JunoSwapReactQuery<InfoResponse, TData> {}
export function useJunoSwapInfoQuery<TData = InfoResponse>({
  client,
  options
}: JunoSwapInfoQuery<TData>) {
  return useQuery<InfoResponse, Error, TData>(["junoSwapInfo", client?.contractAddress], () => client ? client.info() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JunoSwapBalanceQuery<TData> extends JunoSwapReactQuery<BalanceResponse, TData> {
  args: {
    address: string;
  };
}
export function useJunoSwapBalanceQuery<TData = BalanceResponse>({
  client,
  args,
  options
}: JunoSwapBalanceQuery<TData>) {
  return useQuery<BalanceResponse, Error, TData>(["junoSwapBalance", client?.contractAddress, JSON.stringify(args)], () => client ? client.balance({
    address: args.address
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface JunoSwapSwapToMutation {
  client: JunoSwapClient;
  msg: {
    expiration?: Expiration;
    inputAmount: Uint128;
    inputToken: TokenSelect;
    minToken: Uint128;
    recipient: Addr;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJunoSwapSwapToMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JunoSwapSwapToMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JunoSwapSwapToMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.swapTo(msg, fee, memo, funds), options);
}
export interface JunoSwapMultiContractSwapMutation {
  client: JunoSwapClient;
  msg: {
    expiration?: Expiration;
    inputToken: TokenSelect;
    inputTokenAmount: Uint128;
    outputAmmAddress: Addr;
    outputMinToken: Uint128;
    outputToken: TokenSelect;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJunoSwapMultiContractSwapMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JunoSwapMultiContractSwapMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JunoSwapMultiContractSwapMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.multiContractSwap(msg, fee, memo, funds), options);
}
export interface JunoSwapSwapToken2ForToken1Mutation {
  client: JunoSwapClient;
  msg: {
    expiration?: Expiration;
    minToken1: Uint128;
    token2Amount: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJunoSwapSwapToken2ForToken1Mutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JunoSwapSwapToken2ForToken1Mutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JunoSwapSwapToken2ForToken1Mutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.swapToken2ForToken1(msg, fee, memo, funds), options);
}
export interface JunoSwapSwapToken1ForToken2Mutation {
  client: JunoSwapClient;
  msg: {
    expiration?: Expiration;
    minToken2: Uint128;
    token1Amount: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJunoSwapSwapToken1ForToken2Mutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JunoSwapSwapToken1ForToken2Mutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JunoSwapSwapToken1ForToken2Mutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.swapToken1ForToken2(msg, fee, memo, funds), options);
}
export interface JunoSwapRemoveLiquidityMutation {
  client: JunoSwapClient;
  msg: {
    amount: Uint128;
    expiration?: Expiration;
    minToken1: Uint128;
    minToken2: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJunoSwapRemoveLiquidityMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JunoSwapRemoveLiquidityMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JunoSwapRemoveLiquidityMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.removeLiquidity(msg, fee, memo, funds), options);
}
export interface JunoSwapAddLiquidityMutation {
  client: JunoSwapClient;
  msg: {
    expiration?: Expiration;
    maxToken2: Uint128;
    minLiquidity: Uint128;
    token1Amount: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useJunoSwapAddLiquidityMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, JunoSwapAddLiquidityMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, JunoSwapAddLiquidityMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.addLiquidity(msg, fee, memo, funds), options);
}